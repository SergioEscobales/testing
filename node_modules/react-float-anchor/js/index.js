"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fromEventsWithOptions = _interopRequireDefault(require("./lib/fromEventsWithOptions"));

var _LifecycleHelper = _interopRequireDefault(require("./LifecycleHelper"));

var _kefir = _interopRequireDefault(require("kefir"));

var _kefirBus = _interopRequireDefault(require("kefir-bus"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = require("react-dom");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _containByScreen = _interopRequireDefault(require("contain-by-screen"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var requestAnimationFrame = global.requestAnimationFrame || function (cb) {
  return Promise.resolve().then(cb);
};

// Context is used so that when a FloatAnchor has reposition() called on it,
// all of its descendant FloatAnchor elements reposition too.
var FloatAnchorContext = _react["default"].createContext(null);

var FloatAnchor =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2["default"])(FloatAnchor, _React$Component);

  function FloatAnchor() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2["default"])(this, FloatAnchor);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2["default"])(this, (_getPrototypeOf2 = (0, _getPrototypeOf3["default"])(FloatAnchor)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "state", {
      choice: null,
      floatNode: null
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_portalEl", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_portalRemoval", (0, _kefirBus["default"])());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_unmount", (0, _kefirBus["default"])());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_childContext", {
      repositionEvents: (0, _kefirBus["default"])(),
      repositionAsyncQueued: false,
      repositionAsyncEvents: (0, _kefirBus["default"])()
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_anchorRef", null);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_setAnchorRef", function (anchorRef) {
      _this._anchorRef = anchorRef;
      var portalEl = _this._portalEl;

      if (portalEl) {
        // rfaAnchor is also set in _mountPortal. This line is necessary in the case that
        // the anchorRef is updated.
        portalEl.rfaAnchor = anchorRef ? anchorRef : undefined;
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_mountPortalEl", function () {
      var portalEl = _this._portalEl;
      /*:: if (!portalEl) throw new Error(); */

      if (portalEl.parentElement) {
        throw new Error('Should not happen: portalEl already in page');
      }

      var anchorRef = _this._getAnchorRef();

      if (!anchorRef) throw new Error('ReactFloatAnchor missing anchorRef element');
      portalEl.rfaAnchor = anchorRef;
      var target = _this.props.parentElement || document.body || document.documentElement;
      /*:: if (!target) throw new Error(); */

      target.appendChild(portalEl);

      _kefir["default"].merge([_kefir["default"].fromEvents(window, 'resize'), (0, _fromEventsWithOptions["default"])(window, 'scroll', {
        capture: true,
        passive: true
      }).filter(function (event) {
        var anchorRef = _this._getAnchorRef();

        return anchorRef && event.target.contains(anchorRef);
      })]).takeUntilBy(_this._portalRemoval).onValue(function () {
        _this.repositionAsync();
      }).onEnd(function () {
        portalEl.rfaAnchor = undefined;
        /*:: if (!portalEl.parentElement) throw new Error(); */

        portalEl.parentElement.removeChild(portalEl);
      });
    });
    return _this;
  }

  (0, _createClass2["default"])(FloatAnchor, [{
    key: "_getAnchorRef",
    value: function _getAnchorRef() {
      return typeof this.props.anchor === 'function' ? this._anchorRef : this.props.anchor;
    }
  }, {
    key: "_getOrCreatePortalEl",
    value: function _getOrCreatePortalEl() {
      var portalEl_firstCheck = this._portalEl;

      if (portalEl_firstCheck) {
        return portalEl_firstCheck;
      }

      var portalEl = this._portalEl = document.createElement('div');
      portalEl.className = this.props.floatContainerClassName || '';
      portalEl.style.zIndex = String(this.props.zIndex);
      portalEl.style.position = 'fixed';
      return portalEl;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var parentCtx = this.context;

      if (parentCtx) {
        parentCtx.repositionEvents.takeUntilBy(this._unmount).onValue(function () {
          return _this2.reposition();
        });
        parentCtx.repositionAsyncEvents.takeUntilBy(this._unmount).onValue(function () {
          if (!_this2._childContext.repositionAsyncQueued) {
            _this2._childContext.repositionAsyncQueued = true;

            _this2._childContext.repositionAsyncEvents.value(null);
          }
        });

        if (parentCtx.repositionAsyncQueued) {
          this._childContext.repositionAsyncQueued = true;

          this._childContext.repositionAsyncEvents.value(null);
        }
      }

      if (this.state.floatNode != null) {
        // We need to reposition after the page has had its layout done.
        this.repositionAsync();
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      // If the only thing changed is state.choice *and* typeof props.float !== 'function', don't re-render.
      // If nothing has changed, allow the re-render so we keep the same behavior on a plain forceUpdate of a parent.
      // TODO in next major version, don't re-render when nothing has changed.
      if (typeof nextProps["float"] !== 'function' && this.state.choice !== nextState.choice && this.props.anchor === nextProps.anchor && this.props.parentElement === nextProps.parentElement && this.props["float"] === nextProps["float"] && this.props.options === nextProps.options && this.props.zIndex === nextProps.zIndex && this.props.floatContainerClassName === nextProps.floatContainerClassName) {
        return false;
      }

      return true;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var portalEl = this._portalEl;

      if (portalEl) {
        if (this.state.floatNode == null) {
          this._portalRemoval.value(null);
        } else {
          if (prevProps.parentElement !== this.props.parentElement) {
            this._portalRemoval.value(null);

            this._mountPortalEl();
          }

          if (prevProps.floatContainerClassName !== this.props.floatContainerClassName) {
            portalEl.className = this.props.floatContainerClassName || '';
          }

          if (prevProps.zIndex !== this.props.zIndex) {
            portalEl.style.zIndex = String(this.props.zIndex);
          } // If anchor is an HTMLElement and has changed, then update portalEl.rfaAnchor


          if (typeof this.props.anchor !== 'function' && prevProps.anchor !== this.props.anchor) {
            portalEl.rfaAnchor = this.props.anchor;
            this.repositionAsync();
          } else if ( // If this re-render happened because of a change in position choice, don't reposition again now.
          prevState.floatNode !== this.state.floatNode && prevState.choice === this.state.choice || !(0, _isEqual["default"])(prevProps.options, this.props.options)) {
            this.repositionAsync();
          }
        }
      } else {
        if (this.state.floatNode != null) {
          throw new Error('Should not happen: portalEl was null after rendering with float prop');
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._portalRemoval.value(null);

      this._unmount.value(null);

      this._childContext.repositionEvents.end();

      this._childContext.repositionAsyncEvents.end();
    } // Repositions on the next animation frame. Automatically batches with other repositionAsync calls
    // in the same tree.

  }, {
    key: "repositionAsync",
    value: function repositionAsync() {
      var _this3 = this;

      // If we already have a repositionAsync queued up, there's no reason to queue another.
      if (this._childContext.repositionAsyncQueued) {
        return;
      }

      this._childContext.repositionAsyncQueued = true;

      this._childContext.repositionAsyncEvents.value(null);

      requestAnimationFrame(function () {
        // If our parent still has a repositionAsync queued up, then don't fire.
        // The parent may have queued up a repositionAsync in the time since this repositionAsync() was called.
        var parentCtx = _this3.context;

        if (!parentCtx || !parentCtx.repositionAsyncQueued) {
          // Make sure we still have a repositionAsync queued up. It could be that reposition() has been called
          // in the time since repositionAsync().
          if (_this3._childContext.repositionAsyncQueued) {
            _this3._childContext.repositionAsyncQueued = false;

            _this3.reposition();
          }
        }
      });
    }
  }, {
    key: "reposition",
    value: function reposition() {
      // Only clear our repositionAsyncQueued flag if we're not reflecting our parent's true value.
      var parentCtx = this.context;

      if (!parentCtx || !parentCtx.repositionAsyncQueued) {
        this._childContext.repositionAsyncQueued = false;
      }

      var portalEl = this._portalEl;

      var anchorRef = this._getAnchorRef();

      if (portalEl && portalEl.parentElement && anchorRef) {
        var _choice = (0, _containByScreen["default"])(portalEl, anchorRef, this.props.options || {});

        if (!(0, _isEqual["default"])(this.state.choice, _choice)) {
          this.setState({
            choice: _choice
          });
        } // Make any child FloatAnchors reposition


        this._childContext.repositionEvents.value(null);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var anchor = this.props.anchor;
      var _float = this.state.floatNode;
      var floatPortal = null;

      if (_float != null) {
        var portalEl = this._getOrCreatePortalEl();

        floatPortal = _react["default"].createElement(FloatAnchorContext.Provider, {
          value: this._childContext
        }, _react["default"].createElement(_LifecycleHelper["default"], {
          onMount: this._mountPortalEl
        }), (0, _reactDom.createPortal)(_float, portalEl));
      }

      var anchorElement = typeof anchor === 'function' ? anchor(this._setAnchorRef) : null;
      return _react["default"].createElement(_react["default"].Fragment, null, anchorElement, floatPortal);
    }
  }], [{
    key: "parentNodes",
    value:
    /*#__PURE__*/
    _regenerator["default"].mark(function parentNodes(node) {
      return _regenerator["default"].wrap(function parentNodes$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return node;

            case 2:
              if (node = node.rfaAnchor || node.parentNode) {
                _context.next = 0;
                break;
              }

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, parentNodes);
    }) // This property is only used in the case that props.anchor is not an HTMLElement

  }, {
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      return {
        floatNode: typeof props["float"] === 'function' ? props["float"](state.choice) : props["float"]
      };
    }
  }]);
  return FloatAnchor;
}(_react["default"].Component);

exports["default"] = FloatAnchor;
(0, _defineProperty2["default"])(FloatAnchor, "propTypes", {
  anchor: _propTypes["default"].oneOfType([_propTypes["default"].func, _propTypes["default"].object]).isRequired,
  parentElement: _propTypes["default"].object,
  "float": _propTypes["default"].oneOfType([_propTypes["default"].node, _propTypes["default"].func]),
  options: _propTypes["default"].object,
  zIndex: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].string]),
  floatContainerClassName: _propTypes["default"].string
});
(0, _defineProperty2["default"])(FloatAnchor, "contextType", FloatAnchorContext);
module.exports = exports.default;
module.exports.default = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnbG9iYWwiLCJjYiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIkZsb2F0QW5jaG9yQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsIkZsb2F0QW5jaG9yIiwiY2hvaWNlIiwiZmxvYXROb2RlIiwicmVwb3NpdGlvbkV2ZW50cyIsInJlcG9zaXRpb25Bc3luY1F1ZXVlZCIsInJlcG9zaXRpb25Bc3luY0V2ZW50cyIsImFuY2hvclJlZiIsIl9hbmNob3JSZWYiLCJwb3J0YWxFbCIsIl9wb3J0YWxFbCIsInJmYUFuY2hvciIsInVuZGVmaW5lZCIsInBhcmVudEVsZW1lbnQiLCJFcnJvciIsIl9nZXRBbmNob3JSZWYiLCJ0YXJnZXQiLCJwcm9wcyIsImRvY3VtZW50IiwiYm9keSIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwiS2VmaXIiLCJtZXJnZSIsImZyb21FdmVudHMiLCJ3aW5kb3ciLCJjYXB0dXJlIiwicGFzc2l2ZSIsImZpbHRlciIsImV2ZW50IiwiY29udGFpbnMiLCJ0YWtlVW50aWxCeSIsIl9wb3J0YWxSZW1vdmFsIiwib25WYWx1ZSIsInJlcG9zaXRpb25Bc3luYyIsIm9uRW5kIiwicmVtb3ZlQ2hpbGQiLCJhbmNob3IiLCJwb3J0YWxFbF9maXJzdENoZWNrIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImZsb2F0Q29udGFpbmVyQ2xhc3NOYW1lIiwic3R5bGUiLCJ6SW5kZXgiLCJTdHJpbmciLCJwb3NpdGlvbiIsInBhcmVudEN0eCIsImNvbnRleHQiLCJfdW5tb3VudCIsInJlcG9zaXRpb24iLCJfY2hpbGRDb250ZXh0IiwidmFsdWUiLCJzdGF0ZSIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsIm9wdGlvbnMiLCJwcmV2UHJvcHMiLCJwcmV2U3RhdGUiLCJfbW91bnRQb3J0YWxFbCIsImVuZCIsInNldFN0YXRlIiwiZmxvYXQiLCJmbG9hdFBvcnRhbCIsIl9nZXRPckNyZWF0ZVBvcnRhbEVsIiwiYW5jaG9yRWxlbWVudCIsIl9zZXRBbmNob3JSZWYiLCJub2RlIiwicGFyZW50Tm9kZSIsIkNvbXBvbmVudCIsIlByb3BUeXBlcyIsIm9uZU9mVHlwZSIsImZ1bmMiLCJvYmplY3QiLCJpc1JlcXVpcmVkIiwibnVtYmVyIiwic3RyaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUEsSUFBTUEscUJBQXFCLEdBQUdDLE1BQU0sQ0FBQ0QscUJBQVAsSUFBaUMsVUFBQUUsRUFBRTtBQUFBLFNBQUlDLE9BQU8sQ0FBQ0MsT0FBUixHQUFrQkMsSUFBbEIsQ0FBdUJILEVBQXZCLENBQUo7QUFBQSxDQUFqRTs7QUFlQTtBQUNBO0FBQ0EsSUFBTUksa0JBQWtCLEdBQUdDLGtCQUFNQyxhQUFOLENBQTZDLElBQTdDLENBQTNCOztJQWdCcUJDLFc7Ozs7Ozs7Ozs7Ozs7Ozs7OzhGQVlKO0FBQ2JDLE1BQUFBLE1BQU0sRUFBRSxJQURLO0FBRWJDLE1BQUFBLFNBQVMsRUFBRTtBQUZFLEs7O3VHQU1hLDJCO2lHQUNOLDJCO3NHQUNOO0FBQ2RDLE1BQUFBLGdCQUFnQixFQUFHLDJCQURMO0FBRWRDLE1BQUFBLHFCQUFxQixFQUFFLEtBRlQ7QUFHZEMsTUFBQUEscUJBQXFCLEVBQUc7QUFIVixLO21HQWFXLEk7c0dBRVgsVUFBQ0MsU0FBRCxFQUE2QjtBQUMzQyxZQUFLQyxVQUFMLEdBQWtCRCxTQUFsQjtBQUVBLFVBQU1FLFFBQVEsR0FBRyxNQUFLQyxTQUF0Qjs7QUFDQSxVQUFJRCxRQUFKLEVBQWM7QUFDWjtBQUNBO0FBQ0NBLFFBQUFBLFFBQUQsQ0FBZ0JFLFNBQWhCLEdBQTRCSixTQUFTLEdBQUdBLFNBQUgsR0FBZUssU0FBcEQ7QUFDRDtBQUNGLEs7dUdBZ0tnQixZQUFNO0FBQ3JCLFVBQU1ILFFB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RUFBbUJMLHNCQUFVTSxNQUE3QixDQUFwQixDQUxTO0FBTWpCbEMsRUFBQUEsdUJBQXVCLEVBQUU0QixzQkFBVU07QUFObEIsQztpQ0FEQTFFLFcsaUJBVUVILGtCIiwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cblxuaW1wb3J0IGZyb21FdmVudHNXaXRoT3B0aW9ucyBmcm9tICcuL2xpYi9mcm9tRXZlbnRzV2l0aE9wdGlvbnMnO1xuaW1wb3J0IExpZmVjeWNsZUhlbHBlciBmcm9tICcuL0xpZmVjeWNsZUhlbHBlcic7XG5pbXBvcnQgS2VmaXIgZnJvbSAna2VmaXInO1xuaW1wb3J0IGtlZmlyQnVzIGZyb20gJ2tlZmlyLWJ1cyc7XG5pbXBvcnQgdHlwZSB7QnVzfSBmcm9tICdrZWZpci1idXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7Y3JlYXRlUG9ydGFsfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjb250YWluQnlTY3JlZW4gZnJvbSAnY29udGFpbi1ieS1zY3JlZW4nO1xuaW1wb3J0IHR5cGUge09wdGlvbnMsIENob2ljZX0gZnJvbSAnY29udGFpbi1ieS1zY3JlZW4nO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAnbG9kYXNoL2lzRXF1YWwnO1xuXG5jb25zdCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IChjYiA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNiKSk7XG5cbnR5cGUgRmxvYXRBbmNob3JDb250ZXh0VHlwZSA9IHtcbiAgLy8gRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIGNvbXBvbmVudCByZXBvc2l0aW9ucywgc28gdGhlIGNoaWxkcmVuIGNhbiByZXBvc2l0aW9uIHRoZW1zZWx2ZXMgdG8gbWF0Y2guXG4gIHJlcG9zaXRpb25FdmVudHM6IEtlZmlyLk9ic2VydmFibGU8bnVsbD4sXG5cbiAgLy8gU2lnbmlmaWVzIHRoaXMgY29tcG9uZW50IGhhcyBhIHJlcG9zaXRpb25Bc3luYyBxdWV1ZWQgdXAuIENoaWxkcmVuIGNvbXBvbmVudHMgc2hvdWxkIGlnbm9yZSByZXBvc2l0aW9uQXN5bmNcbiAgLy8gY2FsbHMgd2hpbGUgdGhpcyBpcyB0cnVlLiBDaGlsZHJlbiBzaG91bGQgY29weSB0aGVpciBwYXJlbnQgd2hlbmV2ZXIgdGhlaXIgcGFyZW50IHNldHMgdGhlaXJzIHRvIHRydWUuXG4gIC8vIENvbXBvbmVudHMgc2hvdWxkIGNsZWFyIHRoaXMgZmxhZyB3aGVuIHRoZXkgcmVwb3NpdGlvbiB1bmxlc3MgdGhleSBoYXZlIGEgcGFyZW50IHdpdGggaXQgc3RpbGwgc2V0LlxuICByZXBvc2l0aW9uQXN5bmNRdWV1ZWQ6IGJvb2xlYW4sXG5cbiAgLy8gRW1pdHMgZXZlcnkgdGltZSByZXBvc2l0aW9uQXN5bmNRdWV1ZWQgYmVjb21lcyB0cnVlLlxuICByZXBvc2l0aW9uQXN5bmNFdmVudHM6IEtlZmlyLk9ic2VydmFibGU8bnVsbD5cbn07XG5cbi8vIENvbnRleHQgaXMgdXNlZCBzbyB0aGF0IHdoZW4gYSBGbG9hdEFuY2hvciBoYXMgcmVwb3NpdGlvbigpIGNhbGxlZCBvbiBpdCxcbi8vIGFsbCBvZiBpdHMgZGVzY2VuZGFudCBGbG9hdEFuY2hvciBlbGVtZW50cyByZXBvc2l0aW9uIHRvby5cbmNvbnN0IEZsb2F0QW5jaG9yQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8P0Zsb2F0QW5jaG9yQ29udGV4dFR5cGU+KG51bGwpO1xuXG5leHBvcnQgdHlwZSB7T3B0aW9ucywgQ2hvaWNlfSBmcm9tICdjb250YWluLWJ5LXNjcmVlbic7XG5cbmV4cG9ydCB0eXBlIFByb3BzID0ge1xuICBhbmNob3I6ICgoYW5jaG9yUmVmOiBSZWFjdCRSZWY8YW55PikgPT4gUmVhY3QkTm9kZSkgfCBIVE1MRWxlbWVudDtcbiAgcGFyZW50RWxlbWVudD86ID9IVE1MRWxlbWVudDtcbiAgZmxvYXQ/OiA/UmVhY3QkTm9kZSB8ICgoY2hvaWNlOiBDaG9pY2UgfCBudWxsKSA9PiBSZWFjdCROb2RlKTtcbiAgb3B0aW9ucz86ID9PcHRpb25zO1xuICB6SW5kZXg/OiA/bnVtYmVyfHN0cmluZztcbiAgZmxvYXRDb250YWluZXJDbGFzc05hbWU/OiA/c3RyaW5nO1xufTtcbnR5cGUgU3RhdGUgPSB7XG4gIGNob2ljZTogQ2hvaWNlIHwgbnVsbDtcbiAgZmxvYXROb2RlOiA/UmVhY3QkTm9kZTtcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGbG9hdEFuY2hvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhbmNob3I6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZCxcbiAgICBwYXJlbnRFbGVtZW50OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGZsb2F0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBvcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHpJbmRleDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIGZsb2F0Q29udGFpbmVyQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG4gIH07XG5cbiAgc3RhdGljIGNvbnRleHRUeXBlID0gRmxvYXRBbmNob3JDb250ZXh0O1xuXG4gIHN0YXRlOiBTdGF0ZSA9IHtcbiAgICBjaG9pY2U6IG51bGwsXG4gICAgZmxvYXROb2RlOiBudWxsXG4gIH07XG5cbiAgX3BvcnRhbEVsOiA/SFRNTEVsZW1lbnQ7XG4gIF9wb3J0YWxSZW1vdmFsOiBCdXM8bnVsbD4gPSBrZWZpckJ1cygpO1xuICBfdW5tb3VudDogQnVzPG51bGw+ID0ga2VmaXJCdXMoKTtcbiAgX2NoaWxkQ29udGV4dCA9IHtcbiAgICByZXBvc2l0aW9uRXZlbnRzOiAoa2VmaXJCdXMoKTogQnVzPG51bGw+KSxcbiAgICByZXBvc2l0aW9uQXN5bmNRdWV1ZWQ6IGZhbHNlLFxuICAgIHJlcG9zaXRpb25Bc3luY0V2ZW50czogKGtlZmlyQnVzKCk6IEJ1czxudWxsPilcbiAgfTtcblxuICBzdGF0aWMgKnBhcmVudE5vZGVzKG5vZGU6IE5vZGUpOiBJdGVyYXRvcjxOb2RlPiB7XG4gICAgZG8ge1xuICAgICAgeWllbGQgKG5vZGU6IE5vZGUpO1xuICAgIH0gd2hpbGUgKChub2RlID0gKG5vZGU6IGFueSkucmZhQW5jaG9yIHx8IChub2RlOiBhbnkpLnBhcmVudE5vZGUpKTtcbiAgfVxuXG4gIC8vIFRoaXMgcHJvcGVydHkgaXMgb25seSB1c2VkIGluIHRoZSBjYXNlIHRoYXQgcHJvcHMuYW5jaG9yIGlzIG5vdCBhbiBIVE1MRWxlbWVudFxuICBfYW5jaG9yUmVmOiA/SFRNTEVsZW1lbnQgPSBudWxsO1xuXG4gIF9zZXRBbmNob3JSZWYgPSAoYW5jaG9yUmVmOiA/SFRNTEVsZW1lbnQpID0+IHtcbiAgICB0aGlzLl9hbmNob3JSZWYgPSBhbmNob3JSZWY7XG5cbiAgICBjb25zdCBwb3J0YWxFbCA9IHRoaXMuX3BvcnRhbEVsO1xuICAgIGlmIChwb3J0YWxFbCkge1xuICAgICAgLy8gcmZhQW5jaG9yIGlzIGFsc28gc2V0IGluIF9tb3VudFBvcnRhbC4gVGhpcyBsaW5lIGlzIG5lY2Vzc2FyeSBpbiB0aGUgY2FzZSB0aGF0XG4gICAgICAvLyB0aGUgYW5jaG9yUmVmIGlzIHVwZGF0ZWQuXG4gICAgICAocG9ydGFsRWw6IGFueSkucmZhQW5jaG9yID0gYW5jaG9yUmVmID8gYW5jaG9yUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbiAgX2dldEFuY2hvclJlZigpOiA/SFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wcm9wcy5hbmNob3IgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9hbmNob3JSZWYgOiB0aGlzLnByb3BzLmFuY2hvcjtcbiAgfVxuXG4gIF9nZXRPckNyZWF0ZVBvcnRhbEVsKCk6IEhUTUxFbGVtZW50IHtcbiAgICBjb25zdCBwb3J0YWxFbF9maXJzdENoZWNrID0gdGhpcy5fcG9ydGFsRWw7XG4gICAgaWYgKHBvcnRhbEVsX2ZpcnN0Q2hlY2spIHtcbiAgICAgIHJldHVybiBwb3J0YWxFbF9maXJzdENoZWNrO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcnRhbEVsID0gdGhpcy5fcG9ydGFsRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwb3J0YWxFbC5jbGFzc05hbWUgPSB0aGlzLnByb3BzLmZsb2F0Q29udGFpbmVyQ2xhc3NOYW1lIHx8ICcnO1xuICAgIHBvcnRhbEVsLnN0eWxlLnpJbmRleCA9IFN0cmluZyh0aGlzLnByb3BzLnpJbmRleCk7XG4gICAgcG9ydGFsRWwuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgcmV0dXJuIHBvcnRhbEVsO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgcGFyZW50Q3R4OiA/RmxvYXRBbmNob3JDb250ZXh0VHlwZSA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAocGFyZW50Q3R4KSB7XG4gICAgICBwYXJlbnRDdHgucmVwb3NpdGlvbkV2ZW50c1xuICAgICAgICAudGFrZVVudGlsQnkodGhpcy5fdW5tb3VudClcbiAgICAgICAgLm9uVmFsdWUoKCkgPT4gdGhpcy5yZXBvc2l0aW9uKCkpO1xuXG4gICAgICBwYXJlbnRDdHgucmVwb3NpdGlvbkFzeW5jRXZlbnRzXG4gICAgICAgIC50YWtlVW50aWxCeSh0aGlzLl91bm1vdW50KVxuICAgICAgICAub25WYWx1ZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jaGlsZENvbnRleHQucmVwb3NpdGlvbkFzeW5jUXVldWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZENvbnRleHQucmVwb3NpdGlvbkFzeW5jUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkQ29udGV4dC5yZXBvc2l0aW9uQXN5bmNFdmVudHMudmFsdWUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgaWYgKHBhcmVudEN0eC5yZXBvc2l0aW9uQXN5bmNRdWV1ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hpbGRDb250ZXh0LnJlcG9zaXRpb25Bc3luY1F1ZXVlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoaWxkQ29udGV4dC5yZXBvc2l0aW9uQXN5bmNFdmVudHMudmFsdWUobnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUuZmxvYXROb2RlICE9IG51bGwpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gcmVwb3NpdGlvbiBhZnRlciB0aGUgcGFnZSBoYXMgaGFkIGl0cyBsYXlvdXQgZG9uZS5cbiAgICAgIHRoaXMucmVwb3NpdGlvbkFzeW5jKCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wczogUHJvcHMsIHN0YXRlOiBTdGF0ZSk6ICRTaGFwZTxTdGF0ZT4gfCBudWxsIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmxvYXROb2RlOiB0eXBlb2YgcHJvcHMuZmxvYXQgPT09ICdmdW5jdGlvbicgPyBwcm9wcy5mbG9hdChzdGF0ZS5jaG9pY2UpIDogcHJvcHMuZmxvYXRcbiAgICB9O1xuICB9XG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wczogUHJvcHMsIG5leHRTdGF0ZTogU3RhdGUpIHtcbiAgICAvLyBJZiB0aGUgb25seSB0aGluZyBjaGFuZ2VkIGlzIHN0YXRlLmNob2ljZSAqYW5kKiB0eXBlb2YgcHJvcHMuZmxvYXQgIT09ICdmdW5jdGlvbicsIGRvbid0IHJlLXJlbmRlci5cbiAgICAvLyBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCBhbGxvdyB0aGUgcmUtcmVuZGVyIHNvIHdlIGtlZXAgdGhlIHNhbWUgYmVoYXZpb3Igb24gYSBwbGFpbiBmb3JjZVVwZGF0ZSBvZiBhIHBhcmVudC5cbiAgICAvLyBUT0RPIGluIG5leHQgbWFqb3IgdmVyc2lvbiwgZG9uJ3QgcmUtcmVuZGVyIHdoZW4gbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbmV4dFByb3BzLmZsb2F0ICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICB0aGlzLnN0YXRlLmNob2ljZSAhPT0gbmV4dFN0YXRlLmNob2ljZSAmJlxuICAgICAgdGhpcy5wcm9wcy5hbmNob3IgPT09IG5leHRQcm9wcy5hbmNob3IgJiZcbiAgICAgIHRoaXMucHJvcHMucGFyZW50RWxlbWVudCA9PT0gbmV4dFByb3BzLnBhcmVudEVsZW1lbnQgJiZcbiAgICAgIHRoaXMucHJvcHMuZmxvYXQgPT09IG5leHRQcm9wcy5mbG9hdCAmJlxuICAgICAgdGhpcy5wcm9wcy5vcHRpb25zID09PSBuZXh0UHJvcHMub3B0aW9ucyAmJlxuICAgICAgdGhpcy5wcm9wcy56SW5kZXggPT09IG5leHRQcm9wcy56SW5kZXggJiZcbiAgICAgIHRoaXMucHJvcHMuZmxvYXRDb250YWluZXJDbGFzc05hbWUgPT09IG5leHRQcm9wcy5mbG9hdENvbnRhaW5lckNsYXNzTmFtZVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzLCBwcmV2U3RhdGU6IFN0YXRlKSB7XG4gICAgY29uc3QgcG9ydGFsRWwgPSB0aGlzLl9wb3J0YWxFbDtcbiAgICBpZiAocG9ydGFsRWwpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmZsb2F0Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BvcnRhbFJlbW92YWwudmFsdWUobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldlByb3BzLnBhcmVudEVsZW1lbnQgIT09IHRoaXMucHJvcHMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuX3BvcnRhbFJlbW92YWwudmFsdWUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fbW91bnRQb3J0YWxFbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UHJvcHMuZmxvYXRDb250YWluZXJDbGFzc05hbWUgIT09IHRoaXMucHJvcHMuZmxvYXRDb250YWluZXJDbGFzc05hbWUpIHtcbiAgICAgICAgICBwb3J0YWxFbC5jbGFzc05hbWUgPSB0aGlzLnByb3BzLmZsb2F0Q29udGFpbmVyQ2xhc3NOYW1lIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UHJvcHMuekluZGV4ICE9PSB0aGlzLnByb3BzLnpJbmRleCkge1xuICAgICAgICAgIHBvcnRhbEVsLnN0eWxlLnpJbmRleCA9IFN0cmluZyh0aGlzLnByb3BzLnpJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhbmNob3IgaXMgYW4gSFRNTEVsZW1lbnQgYW5kIGhhcyBjaGFuZ2VkLCB0aGVuIHVwZGF0ZSBwb3J0YWxFbC5yZmFBbmNob3JcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLmFuY2hvciAhPT0gJ2Z1bmN0aW9uJyAmJiBwcmV2UHJvcHMuYW5jaG9yICE9PSB0aGlzLnByb3BzLmFuY2hvcikge1xuICAgICAgICAgIChwb3J0YWxFbDogYW55KS5yZmFBbmNob3IgPSB0aGlzLnByb3BzLmFuY2hvcjtcbiAgICAgICAgICB0aGlzLnJlcG9zaXRpb25Bc3luYygpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIC8vIElmIHRoaXMgcmUtcmVuZGVyIGhhcHBlbmVkIGJlY2F1c2Ugb2YgYSBjaGFuZ2UgaW4gcG9zaXRpb24gY2hvaWNlLCBkb24ndCByZXBvc2l0aW9uIGFnYWluIG5vdy5cbiAgICAgICAgICAocHJldlN0YXRlLmZsb2F0Tm9kZSAhPT0gdGhpcy5zdGF0ZS5mbG9hdE5vZGUgJiYgcHJldlN0YXRlLmNob2ljZSA9PT0gdGhpcy5zdGF0ZS5jaG9pY2UpIHx8XG4gICAgICAgICAgIWlzRXF1YWwocHJldlByb3BzLm9wdGlvbnMsIHRoaXMucHJvcHMub3B0aW9ucylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5yZXBvc2l0aW9uQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5mbG9hdE5vZGUgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgaGFwcGVuOiBwb3J0YWxFbCB3YXMgbnVsbCBhZnRlciByZW5kZXJpbmcgd2l0aCBmbG9hdCBwcm9wJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5fcG9ydGFsUmVtb3ZhbC52YWx1ZShudWxsKTtcbiAgICB0aGlzLl91bm1vdW50LnZhbHVlKG51bGwpO1xuICAgIHRoaXMuX2NoaWxkQ29udGV4dC5yZXBvc2l0aW9uRXZlbnRzLmVuZCgpO1xuICAgIHRoaXMuX2NoaWxkQ29udGV4dC5yZXBvc2l0aW9uQXN5bmNFdmVudHMuZW5kKCk7XG4gIH1cblxuICAvLyBSZXBvc2l0aW9ucyBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuIEF1dG9tYXRpY2FsbHkgYmF0Y2hlcyB3aXRoIG90aGVyIHJlcG9zaXRpb25Bc3luYyBjYWxsc1xuICAvLyBpbiB0aGUgc2FtZSB0cmVlLlxuICByZXBvc2l0aW9uQXN5bmMoKSB7XG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgcmVwb3NpdGlvbkFzeW5jIHF1ZXVlZCB1cCwgdGhlcmUncyBubyByZWFzb24gdG8gcXVldWUgYW5vdGhlci5cbiAgICBpZiAodGhpcy5fY2hpbGRDb250ZXh0LnJlcG9zaXRpb25Bc3luY1F1ZXVlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jaGlsZENvbnRleHQucmVwb3NpdGlvbkFzeW5jUXVldWVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jaGlsZENvbnRleHQucmVwb3NpdGlvbkFzeW5jRXZlbnRzLnZhbHVlKG51bGwpO1xuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIElmIG91ciBwYXJlbnQgc3RpbGwgaGFzIGEgcmVwb3NpdGlvbkFzeW5jIHF1ZXVlZCB1cCwgdGhlbiBkb24ndCBmaXJlLlxuICAgICAgLy8gVGhlIHBhcmVudCBtYXkgaGF2ZSBxdWV1ZWQgdXAgYSByZXBvc2l0aW9uQXN5bmMgaW4gdGhlIHRpbWUgc2luY2UgdGhpcyByZXBvc2l0aW9uQXN5bmMoKSB3YXMgY2FsbGVkLlxuICAgICAgY29uc3QgcGFyZW50Q3R4OiA/RmxvYXRBbmNob3JDb250ZXh0VHlwZSA9IHRoaXMuY29udGV4dDtcbiAgICAgIGlmICghcGFyZW50Q3R4IHx8ICFwYXJlbnRDdHgucmVwb3NpdGlvbkFzeW5jUXVldWVkKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzdGlsbCBoYXZlIGEgcmVwb3NpdGlvbkFzeW5jIHF1ZXVlZCB1cC4gSXQgY291bGQgYmUgdGhhdCByZXBvc2l0aW9uKCkgaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgIC8vIGluIHRoZSB0aW1lIHNpbmNlIHJlcG9zaXRpb25Bc3luYygpLlxuICAgICAgICBpZiAodGhpcy5fY2hpbGRDb250ZXh0LnJlcG9zaXRpb25Bc3luY1F1ZXVlZCkge1xuICAgICAgICAgIHRoaXMuX2NoaWxkQ29udGV4dC5yZXBvc2l0aW9uQXN5bmNRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnJlcG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmVwb3NpdGlvbigpIHtcbiAgICAvLyBPbmx5IGNsZWFyIG91ciByZXBvc2l0aW9uQXN5bmNRdWV1ZWQgZmxhZyBpZiB3ZSdyZSBub3QgcmVmbGVjdGluZyBvdXIgcGFyZW50J3MgdHJ1ZSB2YWx1ZS5cbiAgICBjb25zdCBwYXJlbnRDdHg6ID9GbG9hdEFuY2hvckNvbnRleHRUeXBlID0gdGhpcy5jb250ZXh0O1xuICAgIGlmICghcGFyZW50Q3R4IHx8ICFwYXJlbnRDdHgucmVwb3NpdGlvbkFzeW5jUXVldWVkKSB7XG4gICAgICB0aGlzLl9jaGlsZENvbnRleHQucmVwb3NpdGlvbkFzeW5jUXVldWVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcG9ydGFsRWwgPSB0aGlzLl9wb3J0YWxFbDtcbiAgICBjb25zdCBhbmNob3JSZWYgPSB0aGlzLl9nZXRBbmNob3JSZWYoKTtcbiAgICBpZiAocG9ydGFsRWwgJiYgcG9ydGFsRWwucGFyZW50RWxlbWVudCAmJiBhbmNob3JSZWYpIHtcbiAgICAgIGNvbnN0IGNob2ljZSA9IGNvbnRhaW5CeVNjcmVlbihwb3J0YWxFbCwgYW5jaG9yUmVmLCB0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pO1xuICAgICAgaWYgKCFpc0VxdWFsKHRoaXMuc3RhdGUuY2hvaWNlLCBjaG9pY2UpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2Nob2ljZX0pO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIGFueSBjaGlsZCBGbG9hdEFuY2hvcnMgcmVwb3NpdGlvblxuICAgICAgdGhpcy5fY2hpbGRDb250ZXh0LnJlcG9zaXRpb25FdmVudHMudmFsdWUobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgX21vdW50UG9ydGFsRWwgPSAoKSA9PiB7XG4gICAgY29uc3QgcG9ydGFsRWwgPSB0aGlzLl9wb3J0YWxFbDtcbiAgICAvKjo6IGlmICghcG9ydGFsRWwpIHRocm93IG5ldyBFcnJvcigpOyAqL1xuICAgIGlmIChwb3J0YWxFbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgaGFwcGVuOiBwb3J0YWxFbCBhbHJlYWR5IGluIHBhZ2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmNob3JSZWYgPSB0aGlzLl9nZXRBbmNob3JSZWYoKTtcbiAgICBpZiAoIWFuY2hvclJlZikgdGhyb3cgbmV3IEVycm9yKCdSZWFjdEZsb2F0QW5jaG9yIG1pc3NpbmcgYW5jaG9yUmVmIGVsZW1lbnQnKTtcbiAgICAocG9ydGFsRWw6IGFueSkucmZhQW5jaG9yID0gYW5jaG9yUmVmO1xuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5wcm9wcy5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8qOjogaWYgKCF0YXJnZXQpIHRocm93IG5ldyBFcnJvcigpOyAqL1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChwb3J0YWxFbCk7XG5cbiAgICBLZWZpci5tZXJnZShbXG4gICAgICBLZWZpci5mcm9tRXZlbnRzKHdpbmRvdywgJ3Jlc2l6ZScpLFxuICAgICAgZnJvbUV2ZW50c1dpdGhPcHRpb25zKHdpbmRvdywgJ3Njcm9sbCcsIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSkuZmlsdGVyKGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYW5jaG9yUmVmID0gdGhpcy5fZ2V0QW5jaG9yUmVmKCk7XG4gICAgICAgIHJldHVybiBhbmNob3JSZWYgJiYgZXZlbnQudGFyZ2V0LmNvbnRhaW5zKGFuY2hvclJlZik7XG4gICAgICB9KVxuICAgIF0pXG4gICAgICAudGFrZVVudGlsQnkodGhpcy5fcG9ydGFsUmVtb3ZhbClcbiAgICAgIC5vblZhbHVlKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZXBvc2l0aW9uQXN5bmMoKTtcbiAgICAgIH0pXG4gICAgICAub25FbmQoKCkgPT4ge1xuICAgICAgICAocG9ydGFsRWw6IGFueSkucmZhQW5jaG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAvKjo6IGlmICghcG9ydGFsRWwucGFyZW50RWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKCk7ICovXG4gICAgICAgIHBvcnRhbEVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQocG9ydGFsRWwpO1xuICAgICAgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHthbmNob3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBmbG9hdCA9IHRoaXMuc3RhdGUuZmxvYXROb2RlO1xuICAgIGxldCBmbG9hdFBvcnRhbCA9IG51bGw7XG4gICAgaWYgKGZsb2F0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHBvcnRhbEVsID0gdGhpcy5fZ2V0T3JDcmVhdGVQb3J0YWxFbCgpO1xuICAgICAgZmxvYXRQb3J0YWwgPSAoXG4gICAgICAgIDxGbG9hdEFuY2hvckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9eyh0aGlzLl9jaGlsZENvbnRleHQ6IEZsb2F0QW5jaG9yQ29udGV4dFR5cGUpfT5cbiAgICAgICAgICA8TGlmZWN5Y2xlSGVscGVyIG9uTW91bnQ9e3RoaXMuX21vdW50UG9ydGFsRWx9IC8+XG4gICAgICAgICAge2NyZWF0ZVBvcnRhbChmbG9hdCwgcG9ydGFsRWwpfVxuICAgICAgICA8L0Zsb2F0QW5jaG9yQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yRWxlbWVudCA9IHR5cGVvZiBhbmNob3IgPT09ICdmdW5jdGlvbicgPyBhbmNob3IoKHRoaXMuX3NldEFuY2hvclJlZjogYW55KSkgOiBudWxsO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDw+XG4gICAgICAgIHthbmNob3JFbGVtZW50fVxuICAgICAgICB7ZmxvYXRQb3J0YWx9XG4gICAgICA8Lz5cbiAgICApO1xuICB9XG59XG4iXX0=